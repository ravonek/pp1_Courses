#include <iostream> // Основная библиотека
#include <algorithm> // Для различных алгоритмов: sort, reverse и т.д.
#include <vector> // Для контейнера vector
#include <deque> // Для контейнера deque
#include <queue> // Для очередей
#include <stack> // Для стека
#include <set> // Для контейнера set
#include <map> // Для контейнера map
#include <unordered_set> // Для unordered_set
#include <unordered_map> // Для unordered_map
#include <utility> // Для pair
#include <iterator> // Для работы с итераторами
#include <array> // Для контейнера array

int main()
{
                        STL CONTAINERS AND FUNCTIONS

    STL (Standard Template Library) — это мощный инструмент в C++, включающий множество готовых шаблонов контейнеров, итераторов и алгоритмов.

--------------------------------------------------------------------------------

                            VECTOR

    vector — динамический массив, который может менять размер.

    Инициализация:
    vector<int> v1;               // Пустой вектор
    vector<int> v2(5);            // Вектор из 5 элементов со значениями по умолчанию
    vector<int> v3(5, 10);        // Вектор из 5 элементов со значением 10
    vector<int> v4 = {1, 2, 3};   // Вектор из инициализирующего списка

    Основные функции:
    - push_back(): добавляет элемент в конец
    - pop_back(): удаляет элемент с конца
    - size(): возвращает размер вектора
    - empty(): проверяет, пуст ли вектор
    - clear(): очищает вектор
    - insert(): вставляет элементы в указанную позицию
    - erase(): удаляет элементы
    - at(): доступ к элементу по индексу (с проверкой границ)
    - front(), back(): возвращают первый и последний элементы

    Пример:
    vector<int> v = {10, 20, 30, 40};  // Инициализация через список
    vector<int> v2(5, 100);           // 5 элементов, каждый равен 100

    // Добавление элементов
    v.push_back(50);  // {10, 20, 30, 40, 50}
    
    // Удаление последнего элемента
    v.pop_back();  // {10, 20, 30, 40}

    // Доступ к элементам
    cout << v[1] << endl;      // 20
    cout << v.at(1) << endl;   // 20 (с проверкой границ)

    // Размер вектора
    cout << "Size: " << v.size() << endl;

    // Перебор элементов
    for (int x : v) {
        cout << x << " ";
    }
    cout << endl;

    // Вставка элемента
    v.insert(v.begin() + 1, 15);  // {10, 15, 20, 30, 40}
    
    // Удаление элемента
    v.erase(v.begin() + 2);  // {10, 15, 30, 40}

    // Очистка всех элементов
    v.clear();

    // Проверка на пустоту
    if (v.empty()) {
        cout << "Vector is empty!" << endl;
    }

--------------------------------------------------------------------------------

                            DEQUE

    deque (двусторонняя очередь) — структура данных, которая поддерживает вставку и удаление элементов с обеих сторон.

    Инициализация:
    deque<int> d1;               // Пустой deque
    deque<int> d2(5);            // Deque из 5 элементов
    deque<int> d3(5, 10);        // Deque из 5 элементов со значением 10
    deque<int> d4 = {1, 2, 3};   // Deque из инициализирующего списка

    Основные функции:
    - push_front(), push_back(): добавляют элемент в начало/конец
    - pop_front(), pop_back(): удаляют элемент из начала/конца
    - size(): возвращает размер deque
    - empty(): проверяет, пуст ли deque
    - clear(): очищает deque
    - at(), front(), back(): доступ к элементам
    - insert(), erase(): вставка и удаление элементов

    Пример:
     deque<int> dq = {10, 20, 30};

    // Добавление элементов в начало и конец
    dq.push_front(5);  // {5, 10, 20, 30}
    dq.push_back(40);  // {5, 10, 20, 30, 40}

    // Удаление элементов с начала и конца
    dq.pop_front();  // {10, 20, 30, 40}
    dq.pop_back();   // {10, 20, 30}

    // Доступ к элементам
    cout << dq.front() << endl;  // 10
    cout << dq.back() << endl;   // 30

    // Вставка и удаление
    dq.insert(dq.begin() + 1, 15);  // {10, 15, 20, 30}
    dq.erase(dq.begin() + 2);       // {10, 15, 30}

    // Перебор элементов
    for (int x : dq) {
        cout << x << " ";
    }
    cout << endl;
--------------------------------------------------------------------------------

                            SET

    set — контейнер, хранящий уникальные элементы в отсортированном порядке.

    Инициализация:
    set<int> s1;               // Пустой set
    set<int> s2 = {1, 2, 3};   // Инициализация элементами

    Основные функции:
    - insert(): добавляет элемент
    - erase(): удаляет элемент
    - find(): ищет элемент и возвращает итератор
    - size(): возвращает размер
    - empty(): проверяет, пуст ли set
    - clear(): очищает set
    - count(): проверяет наличие элемента (возвращает 0 или 1)

    Пример:
      set<int> s = {30, 10, 20, 20};  // Повторяющиеся элементы игнорируются

    // Вставка элементов
    s.insert(40);  // {10, 20, 30, 40}
    s.insert(10);  // Игнорируется, так как уже есть

    // Удаление элемента
    s.erase(20);  // {10, 30, 40}

    // Поиск элемента
    if (s.find(30) != s.end()) {
        cout << "Found 30!" << endl;
    }

    // Перебор элементов
    for (int x : s) {
        cout << x << " ";
    }
    cout << endl;

--------------------------------------------------------------------------------

                            MAP

    map — ассоциативный контейнер, который хранит пары "ключ-значение".

    Инициализация:
    map<int, string> m1;                 // Пустой map
    map<int, string> m2 = {{1, "one"}, {2, "two"}}; // Инициализация элементами

    Основные функции:
    - insert(): добавляет пару "ключ-значение"
    - erase(): удаляет элемент по ключу
    - find(): ищет элемент по ключу и возвращает итератор
    - size(): возвращает размер
    - empty(): проверяет, пуст ли map
    - clear(): очищает map
    - operator[]: доступ по ключу

    Пример:
    map<int, string> m = {{1, "one"}, {2, "two"}};
    m[3] = "three";  // {1: "one", 2: "two", 3: "three"}
    m.erase(1);      // {2: "two", 3: "three"}

--------------------------------------------------------------------------------

                            UNORDERED SET AND MAP

    unordered_set и unordered_map — неупорядоченные аналоги set и map с более быстрой вставкой и доступом.

    Инициализация аналогична set и map, но элементы не отсортированы.

--------------------------------------------------------------------------------

                            OTHER CONTAINERS

    - stack: реализует LIFO (последний вошел — первый вышел).
    - queue: реализует FIFO (первый вошел — первый вышел).
    - priority_queue: очередь с приоритетом.
    - array: статический массив фиксированного размера.

--------------------------------------------------------------------------------

                        ALGORITHMS AND ITERATORS

    STL также предоставляет богатый набор алгоритмов (sort, reverse, max_element) и итераторов для работы с контейнерами.
}


